## 기능 설계 대 구조 설계

소프트웨어 개발에서는 빈번하게 요구사항 변경이 일어난다.

미래에 대해서 어떤 변경이 일어날 지를 예측하는 것이 아닌, **변경은 필연적으로 발생**하므로

**변경에 용이한 안정적인 구조**를 만드는것이 중요하다.

기존에 기능에 취중한 설계로서 기능에 구조를 종속시키고, 자주 변경되는 기능에 대해 기능 분할을 수행하였다.

세세하게 분해된 기능들은 서로 밀접한 관계를 가진체로 덩어리를 이루게 된다.

덩어리 속 기능중 하나만 삐끗 하더라도 전체가 흔들리게 된다.

이에 비해 객체지향 접근방법은 안정적인 구조를 바탕으로 시스템의 기능을 객체간의 책임으로 분배한다.

여기서 말하는 구조는 객체의 구조를 의미하며, 책임을 객체에게 분배하기에 자연스럽게 기능이 구조를 따르게 된다.

기능이 변경되더라도, 기존의 객체의 구조는 크게 달라지지 않는다.

- 기능 측면의 설계: 제품이 사용자를 위해 무엇(what)을 할 수 있는지
- 구조 측면의 설계: 제품의 형태가 어떠해야 하는지


이러한 '구조'는 사용자나 이해관계자들이 도메인에 관해 생각하는 개념과 개념들과의 관계로 표현한다.

그리고 구조를 안정적이게 설계한 뒤로는 '기능'을 사용자의 목표를 만족시키기 위해 책임을 수행하는 시스템의 행위로 표현한다.

현실세계의 도구로서 '구조'를 표현하기 위해서는 `도메인 모델링`이라고 하고

'기능'을 표현하는 기법을 `유스케이스 모델링`이라고 한다.

## 구조

구조는 사용자나 이해관계자들이 도메인에 관해 생각하는 개념과 개념들과의 관계라고 하였다.

여기서 `도메인`은 `사용자가 프로그램을 사용하는 대상 분야`를 뜻한다.

```
의사(사용자) 는 병원(대상 분야)에서 환자들의 진료기록을 보관하고 분석하는 소프트웨어가 필요하다.
```

그리고 이러한 '구조'를 표현하기 위해 `도메인 모델링`을 하는데, 모델링은 대상을 `문제에 집중할 수 있는 필요한 지식만 재구성한 것`을 의미한다.

여기서 이 두가지 단어 `도메인` 과 `모델링`을 합쳐서 의미는 아래와 같다.

```
사용자가 프로그램을 사용하는 대상 영역에 관한 지식을 선택적으로 단순화 하고 의식적으로 구조화한 형태

소프트웨어가 목적하는 영역 내의 개념과 개념간의 관계, 다양한 규칙이나 제약등을 주의 깊게 추상화 한 형태

소프트웨어 개발과 관련된 이해관계자들이 도메인에 대해 생각하는 관점
```

### 멘탈 모델

멘탈 모델은 사람들이 상호작용하는 사물들에 대해 갖는 모형이다.

현실세계의 상호작용 대상을 이해하기 위해서는 해당 대상에 대한 멘탈 모델을 자연스럽게 떠올리게 된다.

이는 소프트웨어 사용자도 마찬가지다

따라서 소프트웨어를 설계할 때, 사용자들의 해당제품에 대한 멘탈모델과 정확하게 일치해야 한다.

왜냐하면 해당사용자는 멘탈모델과 유사하게 해당 소프트웨어가 작동할 것이라고 기대하기 때문이다.

그래서 멘탈 모델은 `사용자 모델`, `디자인 모델`, `시스템` 으로 나뉜다.

`디자인 모델`은 설계자가 생각하는 시스템에 대한 개념이다.

`시스템`은 코드로 표현된 최종 제품이다.

설계자는 사용자와 직접적으로 소통하지 않고, 제품을 통해 사용자와 소통한다.

따라서 사용자가 생각하는 `사용자 모델`에 가장 가까운 형태를 설계자가 `디자인 모델`로 만드는것이 중요하다.

그리고 이러한 3가지 모델을 모두 포괄하고 추상화한 소프트웨어 모델을 `도메인 모델`이라고 한다.

결국 `도메인 모델`은 소프트웨어에 대한 멘탈 모델이 된다.

### 객체지향과 도메인 모델

객체지향을 활용하면 아까 안정적인 구조를 기반으로 기능을 종속시키는 설계가 가능하다고 하였다.

그 이유는 도메인 모델의 3가지 요소를 모두 유사한 형태로 표현할 수 있기 때문이다.

사용자가 직접 느낄수 있는 실체를 시스템의 객체로 표현하고, 동적인 객체의 복잡성을 단순화한 클래스로 

마지막으로 클래스라는 도구를 통해 타입을 표현할 수 있다.

이러한 특성을 `연결완전성` 또는 `표현적차이` 라고 부른다.

### 표현적 차이

앞서 자율적인 객체들이 공동의 목표를 향해 서로 소통하는것이 객체지향이라고 알고있다.

여기서 객체들이 동적으로 사는 세계를 새롭게 창조하는것이지, 현실세계를 추상화 하는것이 아니다.

아에 안쓰는건 아니고 현실세계의 객체를 통해 사용자들이 '은유'를 사용해서 기능을 유추하는데 도움을 줄 순 있다.

그래서 객체지향의 세계속 객체와 현실 객체와의 차이를 `표현적 차이`라고 한다.

```
<현실세계의 사람> - 현실세계 객체 <- 은유 -> 객체지향 세계 객체 - <객체지향 설계자>
```

여기서 은유를 통해 투영해야 하는 대상이 현실에 존재하지 않는 것들일 수도 있다.(몬스터, 던전 등)

그렇기 때문에, 사용자가 `도메인`에 대해 생각하는 개념들을 기반으로 투영해야 한다. 즉 `도메인 모델`이 된다.

이러한 표현적 차이가 중요한 이유는 소프트웨어를 이해하고 수정하기 쉽게 만들어주기 때문이다.

### 안정적인 도메인 모델

도메인 모델은 사용자가 바라보는 관점 혹은 개념을 반영한다. 

여기서 사용자 관점을 반영하는 이유는 그 누구보다도 '본질적인' 측면을 가장 잘 이해하고 있기 때문이다.

`본질적` 이란 뜻은 변경이 적고 비교적 그 특성이 오랜 시간 유지된다는 것을 의미한다.

따라서 도메인모델을 사용해서 설계하면 변경에 대해서 수용가능한 안정적인 구조를 얻을 수 있다.

## 기능

즉, 도메인 모델은 설계자와 사용자 그리고 시스템 모델 세가지를 사용자가 바라보는 도메인에 대한 관점을 바라보게 하는 모델이다.

그렇기때문에 사용자의 본질적인 측면을 최대한 반영할 수 있어 안정적일수 있다.

하지만 도메인모델만 가지고서는 사용자에게 보여줄수 있는것이 없다. 즉 사용자에게 시스템으로 제공하는것은 `기능`이다

### 유스케이스

기능적 요구사항은 사용자와 사용자가 목표를 만족시키기 위한 시스템간의 '상호작용'이라고 봐야한다.

```
사용자 <--> 시스템
```

이러한 '상호작용'을 텍스트로 정리한 것이 바로 `유스케이스`가 된다.

유스케이스 내에는 일차 액터라는 것이 있고, 이는 위에서 말하는 목표를 가지고 접근하는 액터를 뜻한다.

꼭 사용자와 시스템간만이 아닌, 시스템과 시스템간에 목표를 갖고 접근하는것도 액터라고 표현할 수 있다.

유스케이스의 장점은 산발적으로 흩어진 기능들을 사용자의 목표라는 문맥으로 묶을수 있다.

### 유스케이스의 특성

- 유스케이스는 하나의 시나리오가 아니라 여러 시나리오들의 집합이다.
    - 시나리오는 유스케이스를 통해 시스템을 사용하는 하나의 특정한 이아기 또는 경로다.
    - 시나리오는 다른말로 `유스케이스 인스턴스`라고 한다.

- 유스케이스는 단순한 피쳐(Feature) 목록과는 다르다.
    - 피처는 단순히 기능을 나열한 것 뿐이라 독립적으로 보여진다.
    - 유스케이스는 독립적인 기능들이 아닌 하나의 스토리로 묶을 수 있다.

- 유스케이스는 사용자 인터페이스와 같은 관련된 세부정보를 포함하지 말아야한다.
    - 사용자 인터페이스는 자주 변경되는 요소이므로 배제해야 한다.
    - 이렇게 배제한 유스케이스 형식을 `본질적인 유스케이스`라고 한다.

- 유스케이스는 내부 설계와 관련된 정보를 포함하지 않는다.
    - 유스케이스의 목적은 상호작용에 관련한 기능들을 하나의 스토리로 묶는 역할을 수행하는 것이다.
    - 유스케이스에서 객체 설계로의 전환은 어떤 규칙이 있는것이 아니라 경험과 상식과 의사소통을 통한 창조의 세계이다.


## 합치기 (유스케이스 + 도메인 모델) 및 책임-주도 설계

변경에 유연한 소프트웨어를 만들기 위해서는 유스케이스에 정리된 시스템의 기능을 도메인 모델을 기반으로 한 객체들의 `책임`으로 분배해야 한다.

객체지향 세계에서는 사용자로부터 메세지를 받아 책임을 수행하는 거대한 객체로 볼 수 있다.

해당 책임을 수행하는 거대한 객체인 시스템은 시스템 속 작은 객체들의 `협력`으로 유지된다.

즉, 시스템에 할당된 커다란 책임은 시스템안의 작은 규모의 객체들이 수행해야하는 책임이 된다.

여기서 책임을 수행할 객체는 도메인 모델을 기반으로 은유하는 소프트웨어 객체를 선택하고

해당 객체를 일반화할 클래스를 만들고 속성과 함께 메서드를 구현하면 기능이 완성된 것이다.

여기서 책임-주도 설계와 비슷하게 진행되는것을 볼 수 있다.

책임-주도 설계에서는 하나의 시스템을 구성하기 위해 필요한 책임들을 선별하고, 그 책임들을 수행할 자율적인 객체를 선별한다.

즉, 시스템의 기능을 `역할`과 `책임`을 수행하는 객체들의 `협력관계`로 봄으로서 유스케이스와 도메인 모델을 합친다.

도메인 모델이 어떤 협력을 위한 자율적인 객체로 변환될때, 모델 내의 개념들은 실세계에서는 수동적이겠지만 객체지향 세계에서는 슷로 판단하고 행동하게 된다.

그리고 객체지향 세계로 들여와서 **객체의 이름을 정할때에는 도메인 모델에 포함된 개념**으로 차용하고 **책임은 정의한 개념의 정의 부합**하도록 할당한다.

그리고 책임을 할당할 때에는 책임을 수행하는데 필요한 정보를 가진 객체에게 그 책임을 할당하는 것이다.

```
이자를 계산하는 이자율 객체가 있다.
이자 객체는 이자율 객체에 의해 생성되게 된다.

즉 이자율 객체는 이자 객체의 정보를 갖고 있기에 이자율 객체에게 '이자를 계산하라'라는 책임이 부여된다.
```

### 연결완전성과 가역성

안정적인 모델인 도메인모델을 가지고 객체 구조를 설계하는 이유는 비즈니스 정책이나 규칙 혹은 비즈니스 자체가 사라지지않은 이상 유지되기 때문이다.

```
정기예금이란 도메인에서 정기예금, 계좌, 이자율 그리고 이자란 정기예금이란 도메인 즉, 비즈니스가 사라지지 않은이상 안정적으로 유지된다.

정기예금 도메인에서 이자는 만기시 혹은 중도 해지시에도 상관없이 단 한번만 지급된다. 이자를 지급하는 규칙으로서 정책이 달라지더라도 규칙이 변하지않으면 안정적으로 유지된다.
```

이러한 안정적인 모델인 도메인 모델을 가지고 객체지향 세계를 만들어 나가는데 있어서 전혀 껄끄러움이 없다. 이와같은 특성을 `연결완전성`이라고 한다.

또한 객체지향 세계의 수정을 일으켰을 때에도 도메인 모델에 반영하는데 큰 문제가 없다. 이를 `가역성`이라고 한다.

## 결론

안정적인 도메인 모델을 기반으로 시스템의 기능을 구현하라.

도메인 모델과 코드를 밀접하게 연관시키기 위해 노력하라.

그것이 유지보수하기 쉽고 유연한 객체지향 시스템을 만드는 첫걸음이 될 것이다.






