## 추상화 기법

`추상화`는 도메인의 복잡성을 단순화하고 직관적인 멘탈 모델을 만드는 데 사용할 수 있는 가장 기본적인 인지 수단이다.

여기서 멘탈 모델은 해당 사물 혹은 객체에 대해 머리속으로 떠올리는 개념이다.

추상화 기법에는 다음의 3가지가 제시된다.

- `분류와 인스턴스화`: 객체의 구체적인 세부 사항을 숨기고 인스턴스 간에 공유하는 `공통적인 특성`을 기반으로 `범주`를 형성하는 과정이다. 분류의 역은 범주로 부터 객체를 생성하는 `인스턴스`화 과정이다.

- `일반화와 특수화`: `일반화`는 범주 사이의 차이를 숨기고 범주 간에 공유하는 공통적인 특성을 강조한다. 일반화의 역을 `특수화` 라고한다.

- `집합과 분해`: 부분과 관련된 세부 사항을 숨기고 부분을 사용해서 전체를 형성하는 과정을 가리킨다. 집합으 반대 과정은 전체를 부분으로 분리하는 분해 과정이다.

### 분류와 인스턴스화 

객체를 분류하고 범주로 묶는 것은 객체들의 특정 집합에 공통의 `개념`을 적용하는 것을 의미한다.

여기서 `개념`은 속성과 행위가 유사한 객체의 공통적으로 적용되는 관념이나 아이디어이다.

그리고 세상에 존재하는 객체에 개념을 적용시키는 과정을 `분류`라고 한다.

요약하면 분류는 객체와 타입간의 관계를 나타낸 것으로서, 

어떤 객체가 타입의 정의에 부합할 경우 그 객체는 해당 타입으로 분류되며 자동으로 `타입의 인스턴스`가 된다.

객체는 여러 타입에 속해 있을수도 있고, 하나의 타입에 속해있을 수도 있다. 이를 `단일 분류`와 `다중 분류`라고 한다. 

다중 분류는 특정한 타입없이 하나의 객체가 여러 타입을 가질 수 있다는 것으로서, 하나의 객체가 여러 슈퍼타입을 가질 수 있다는 의미인 `다중 상속`과 헷갈려선 안된다.

그리고 객체가 자신이 속한 타입을 변경할 수 있는것을 `동적 분류`라고 하고, 그 반대를 `정적 분류`라고 한다.

실제로 객체지향 언어로 구현할 때에는 `다중 분류`와 `동적 분류`를 구현하기 힘들다. 따라서 단순함을 위해서는 `단일 분류`와 `정적 분류`를 선택하는것이 현명하다.

### 일반화와 특수화

객체지향의 세계에서 범주는 개념을 의미하고 개념은 곧 타입이므로, 일반화와 특수화는 계층 구조 안에 존재하는 `타입간의 관계`를 의미한다.

서브타입은 슈퍼타입의 본질적인 속성을 모두 포함하기 때문에, 계층에 속하는 **모든 서브타입들이 슈퍼타입의 속성을 공유**한다.

이같은 일반화의 특징을 사용하면, 부분적인 사실을 모르더라도 복잡한 사실에 대한 논리적인 추론이 가능해진다.

어떤 타입이 다른 타입의 서브타입이 되기 위해서는 `100% 규칙` 과 `Is-a 규칙`을 준수해야 한다고 말한다.

- `100% 규칙`: 슈퍼타입 정의가 100% 서브타입에 적용되어야 하고, 서브타입은 속성과 연관관계에서 슈퍼타입과 100% 일치해야 한다.

- `Is-a 규칙`: 서브타입의 모든 인스턴스는 슈퍼타입에 포함되어야 한다.

프로그래밍 언어에서 일반화와 특수화 관계를 구현하는 방법은 **클래스간의 상속**이다. 하지만 모든 상속 관계가 일반화 관계는 아니다.

일반화의 원칙은 `구조적인 순응`과 `행위적인 순응`에 대해서 슈퍼타입에 적용되어야 한다. 이는 곧 `대체 가능성`으로 이어진다.

`구조적인 순응`은 `100% 규칙`과 같다. `행위적인 순응`은 흔히 `리스코프 치환원칙(Liskov Substitution Principle, LSP)` 이라고 하며, 슈퍼타입의 행위를 서브타입의 행위가 대체할 수 있어야 한다.

위의 모든 상속은 일반화 관계를 가지지않는 이유는 클래스간의 상속이 코드 중복을 방지하고 재사용하기 위한 목적으로도 사용하기 때문이다.

즉, 서브클래스가 슈퍼클래스를 대체할 수 있는 경우를 `서브 타이핑`이라고 하고 `인터페이스 상속`이라고 한다.

그 반대의 경우로 대체할 수 없는 경우를 `서브 클래싱`이라고 하고 `구현 상속`이라고 한다.

여러 클래스로 구성된 상속계층에서, 수신된 메시지를 서브클래스가 이해할 수 없다면, 슈퍼클래스로 `위임(delegation)`하게 된다.

여기서 클래스로 타입을 구현하는 언어의 경우에는 `클래스간의 위임`이 이뤄지고, 프로토타입 기반 언어에서는 부모 객체를 연결하여 부모 객체에 위임한다. 그래서 `객체간의 위임`이 이뤄진다.

### 집합과 분해

안정적인 형태의 부분으로 부터 전체를 구축하는 행위를 `집합` 이라고 하고 집합과 반대로 전체를 부분으로 분할하는 행위를 `분해` 라고 한다.

집합은 불필요한 세부사항을 감춰주기 때문에 `추상화` 메커니즘인 동시에 `캡슐화` 메커니즘이다.

외부에서는 전체에 관해서만 알고 있고, 내부의 세부 사항에 대해서는 알지 못하기 때문에 내부의 구성을 변경하더라도 외부에 영향을 미치지 않는다.

객체와 객체사이의 `전체-부분 관계`를 구현하기 위해서는 `합성 관계`를 사용해야 한다.

```
상품과 주문, 주문항목이라는 객체가 있다.

손님이 상품을 바라보고 개수를 선정하여 주문항목을 주문에 대해서 추가할 수 있다.

주문항목은 주문에 의해 생성되는 것이며, 어떠한 주문항목도 주문없이 독립적으로 존재할 수 없다.
```

```java
public class Order{
    
    private List<OrderItem> orderList;

    public Order(List<OrderItem> orderList){
        this.orderList = orderList;
    }

    static class OrderItem{
        private Integer itemId;
        private Integer count;
    }
}

class Item{
    private Integer id;
    private String name;
}
```

`합성 관계`는 부분을 전체 안에 캡슐화함으로써 인지 과부화를 방지한다.

결국 위의 예시를 기반으로 도메인모델을 만들어서 설계하는 설계자입장에서, 주문항목은 주문에 포함되는 것으로서 단순히 주문과 상품이 있다는 큰 맥락만 파악할 수 있다.

여기서 **상품과 주문의 관계는 주문과 주문항목의 관계와 같지않다**.

왜냐하면 주문을 없애더라도 상품은 독립적인 생명주기를 가지기 때문이다.

이러한 단순한 물리적 통로가 존재한다는 사실만 나타내는것을 `연관관계`라고 표현한다.

소프트웨어의 구조를 단순화 하기 위해서는 `합성 관계` 뿐만아니라 서로 관련성 높은 클래스 집합을 논리적인 단위로 통합해야 하며, 이를 `패키지` 또는 `모듈` 이라고 한다.

패키지를 사용하면 개별 클래스가 아닌 클래스의 집합을 캡슐화 할 수 있고, 함께 협력하는 응집도 높은 클래스 집합을 하나의 패키지 내부로 모으면 코드를 이해하기 위해 패키지 경계를 넘나들 필요가 없다.


