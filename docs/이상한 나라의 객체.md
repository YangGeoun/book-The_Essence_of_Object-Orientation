### 객체 지향과 인지능력

우리가 현실세계에 있는 많은 사물들을 객체로 볼수 있다.

하지만 소프트웨어 세계의 객체는 스스로 동작하고 다른 객체를 호출하기도 한다.

현실세계에서는 전등이 누군가에 의해 켜진다 가 맞지만

소프트웨어 세계의 전등은 스스로 킴과 끔의 행동을 할 수 있다.

## 객체 그리고 이상한 나라

이상한나라의 엘리스 예시를 통해 객체의 구성요소와 각 구성요소별 특징을 이해할 수 있다.

객체는 `상태`와 `행위` 그리고 `메시지` 와 메시지를 결국 처리하는 `메서드`를 갖고있다.

객체는 사적인 요소는 철저하게 개인적으로 관리하고 대신, 외부에 공개되는 행위들로 다른 객체들과 협력한다.

여기서 엘리스를 객체화 한다면 여러 `상태`가 보인다.

바로 "키"가 된다. 이러한 "키"가 엘리스의 행위에 따라 변화하는것에 주목하자.

결국 엘리스 자신의 **상태에 변화를 줄 수 있는것은 행위**이고, **행위의 결과는 상태에 의존**적이게 된다.

```
자신의 상태에 변화를 줄 수 있는 행위 -> 음료 마시기, 케이크 먹기

행위의 결과가 상태에 의존적이었던 케이스 -> "문 넘어가기" 라는 행위는 키가 작아야 가능하다.
```

또한 이렇게 상태값(키)이 변화하고, 여러 행위(음료 마시기 등)를 하더라도 엘리스 객체는 엘리스 객체로서 달라지지 않는다.

즉, 엘리스는 상태변화와 상관없이 엘리스 라는 존재로 **식별**할 수 있다.

## 객체 그리고 소프트웨어 나라

결국 객체는 `상태`, `행동`, `식별자`를 지닌 실체이다.

### 상태

위의 엘리스의 예제 처럼, 특정 `행동`이 객체의 상태에 따라 결과가 달라지는것을 볼 수 있다.

```
키(엘리스 상태)가 너무 크면 "문 넘어가기" 행동의 결과가 false가 된다.

키(엘리스 상태)가 적당하면 "문 넘어가기" 행동의 결과가 true가 된다.
```

즉, 현재 내가 바라보고자 하는 행동의 결과값은, 과거의 행동들에 의존적이라는 것이다.

만약 엘리스가 과거에 음료수나 케이크를 먹었냐/안먹었냐 에 따라 현재의 "문 넘어가기" 행위의 결과가 결정된다.

그렇다고 엘리스가 지금까지 했던 행동들을 다 기억하고 있을순 없다.

따라서 `상태`를 도입하여 과거에 어떤 행동들을 했는진 몰라도 지금 내가 하려는 행위의 결과를 얻는데는 문제가 없다.

여기서 엘리스 객체의 상태로 "키"와 "위치"를 알 수 있다.

"위치" 상태는 "문 넘어가기"의 결과로 달라질 수 있다.

엘리스가 마시는 음료라는 객체는 "양"을 상태로 갖고 있다.

여기서 "키", "위치", "양"과 같이 객체의 특성을 나타내는 모든 **정적**인 것을 `프로퍼티` 라고 한다.

그리고 `프로퍼티`의 값이되는 것으로 "키" 라면 "160cm" 처럼 프로퍼티의 값이자, 행위의 결과로 **동적**으로 변화하는 것을 `프로퍼티 값`이라고 한다.

또한 엘리스는 탁자위에 음료를 가져가고 마셧다. 여기서 음료를 객체로 본다면

엘리스 객체는 음료 객체의 "마시다" 라는 메세지를 전달하는 의미인 "마셔지다" 메소드를 호출 할 것이다.

엘리스 입장에서는 메소드만 호출하여 메세지만 전달할 뿐, 어떤 과정이 뒤에 있는지는 관심이 없을것이고

음료 객체 입장에서는 "마시다"라른 메시지를 전달받아서 스스로의 "양" 이라는 프로퍼티의 값을 감소시키는 행위를 할 것이다.

여기서 엘리스 객체가 어쨋든 음료 객체를 호출하려면 음료 객체와 어떤 **연관관계**를 가진다.

이와같이 객체간의 의미 있는 연결을 통해 서로 요청을 보내고 응답할 수 있는 것을 `링크` 라고 한다.

그밖에 객체를 구성하는 단순한 값은 `속성` 이라고도 한다.

정리 해보면

```
객체는 행위와 상태로 이루어져 있고 이것을 통해 책임과 역할을 수행할 수 있다.

여기서 상태는 행위의 결과로 달라지거나, 행위의 결과값에 의존적임

상태에서 정적인 특성을 프로퍼티 라고 하고, 그 값을 프로퍼티값이라고 함

           프로퍼티         프로퍼티 값
aliceObject.height (Integer) =      160     -> 어트리뷰트
aliceObject.location (String) =     "나무"  -> 어트리뷰트
aliceObject.beverage (Beverage) =   식별자  -> 링크

위에서 beverage와 같이 프로퍼티에서 요청을 보내고 받는 객체를 링크(link)라고 한다.
또한 링크를 제외하고 단순한 값들은 속성(attribute)에 해당한다.
```

링크로 연결된 객체라고 해서 해당 객체의 상태에 직접 접근하고 변경할 수 없다.

따라서 해당 객체의 상태를 변경하거나 조회하기 위해 방법으로 `행동`이 등장한다.

객체는 기본적으로 상태와 행위를 묶어놓은 집합체이고, 여기서 자율적인 객체가 되기위해

스스로 책임과 역할을 수행하기 위한 사적인 데이터를 감추고 오픈시켜놓은 `행동`을 통해 다른 객체들과 소통한다.

정리

상태라는 건 특정 시점에서 객체가 갖고있는 정보의 집합으로 구조적 특징을 표현한다.

정적인 프로퍼티와 동적인 프로퍼티 값으로 구성되어 있고 프로퍼티는 다른 객체를 참조하는 링크와 단순한 값(어트리뷰트)을 나타낸다.

### 행동

우리는 엘리스 객체의 예시로 객체의 상태는 행동에 의해 결정되고

행동의 결과는 당시 상태에 의존적인것을 알고 있다.

또한 프로퍼티의 종류중 `링크`를 통해 다른 객체와 소통하는것을 알고있다.

여기서 엘리스가 키에 변화를 주기 위해서 음료수를 마셧던것을 기억하면

결국 엘리스 객체는 링크된 음료 객체와 협력하여 공동의 목표인 키에 변화를 실천한 것이다.

여기서 엘리스가 음료수를 마심으로서 음료수에게 "마시기" 라는 메세지가 전달 될 것이고

"마시기"라는 메세지는 결국 "마셔지다"라는 메소드를 호출하는것과 같다.

"마셔지다" 메소드는 음료객체 스스로가 판단하여 어떤 내부동작을 가질지 결정한다.

여기서는 "양"에 변화를 줄 것이다.

여기서 당시 상태가 "마셔지다"의 결과를 결정지을 것이고 이 반환값은 메세지 전송자인 엘리스 객체가 받을 것이다.

여기서 해당 메세지를 어떻게 처리할지도 사실상 엘리스 객체의 몫이다.

또한 엘리스는 음료수에게 "마시기" 메세지를 전달하기 위해 메소드를 호출할 때, 음료 객체의 상태변화에 관심 가질 필요가 없다.

이렇게 상태를 외부로 노출 시키지 않고, 잘 정의된 행동들로 **캡슐**화 하는것은 객체의 자율성과 협력을 단순하고 유연하게 만든다

### 식별자

객체가 식별 가능하다는 것은 객체를 서로 구별할 수 있는 특정한 `프로퍼티`가 객체안에 존재하는것을 의미한다.

이러한 프로퍼티의 타입은 `링크`냐 `어트리뷰트`냐에 따라 객체 혹은 단순한 값이 될 수 있다.

여기서 값은 식별자를 가지지 못한다. 반대로 객체는 식별자를 가지게 된다.

그리고 값은 변하지 않는 양을 모델링 한다. 값의 상태는 변하지 않기 때문에 불변 상태를 가진다고 한다.

값의 경우에는 두 인스턴스의 상태가 같다면 두 인스턴스를 같다고 판단한다.

이처럼 상태를 이용해 두 값이 같은지 판단할 수 있는 성질을 `동등성`이라고 한다.

객체는 시간에 따라 변경되는 상태를 포함하며, 행동을 통해 상태를 변경한다.

따라서 객체는 `가변 상태`를 가진다고 말하기도 한다.

타입이 같은 두 객체의 상태가 완전히 똑같다고 하여도 두 객체는 별개의 객체로 다뤄야 한다.

이와 동시에 하나의 객체의 값이 달라진다 하더라도, 그 객체는 그 객체만의 식별자를 가진다.

이렇게 식별자를 기반으로 객체가 같은지를 판단하는 성지를 `동일성` 이라고 한다.

하지만 숫자는 `Integer` 클래스로 나타내고, 사람은 `Person`으로 나타내고...

객체지향의 관점에서는 모든 값과 객체는 클래스로 부터 나온 객체이다.

따라서 의미가 모호해질 가능성이 있기에,

식별자를 지닌 전통적인 의미의 객체를 `참조 객체`와 `엔티티` 라고 부르고

식별자를 가지지 않는 값을 가리키는 것을 `값 객체(Value Object)`라고 부른다.

### 조회와 명령

객체의 상태를 확인하는 것과 병경하는 것 모두 객체를 구성하고 있는 `행동`을 유발하기 위해

`메세지`를 전달하는것 과 유사하다.

여기서 중요한 것은 사용자는 `메세지`를 전달할 뿐이지 그 `메세지`에 따른 행동은 객체 스스로 결정한다.

여기서 객체의 상태를 확인하는 작업을 `쿼리` 라고 부르고 상태를 변경하는 작업을 `명령` 이라고 부른다.

### 행동이 상태를 결정한다.

객체지향에 갓 입문한 사람들이 쉽게 빠지기 쉬운 함정은

"상태를 중심으로 객체를 바라보는 것" 이다.

하지만 이렇게 상태를 먼저 결정하고 행동을 나중에 결정하는 방법은 설계에 악영향을 끼친다.

왜냐하면 객체는 서로 협력해야 공동의 목표를 이룰 수 있기 때문이다.

우리는 설계자로서 **협력의 문맥에 맞는 적절한 행동을 수행하는 객체를 발견하거나 창조**해야한다.

즉, 객체지향 설계는 애플리케이션에 필요한 `협력`을 생각하고

그 협력을 이루는데 데 필요한 `행동`을 생각하고, 그 행동을 수행할 `객체`를 `발견`하거나 `창조`하는 방식으로 수행된다.

행동은 결국 객체가 갖고있는것이고, 그 행동을 수행하는데 필요한 상태를 선택하게 된다.

여기서 공동의 목표를 달성하기 위해 협력에 필요한 행동을 `책임`이라고 한다.

### 은유와 객체

현실속의 객체를 객체지향 세계로 갖고 오면 능동적으로 변화한다.

이러한 객체의 특징을 `의인화` 라고 부른다.

하지만 객체지향속 객체와 현실속 객체사이는 완전히 동떨어지진 않았고 `은유`를 통해 설명이 가능하다.

`은유`는 실제로는 적용되지 않는 개념을 이용해 다른 개념을 서술하는 대화의 형태이다.

객체지향속 세계의 `전화기`가 어떤 행동이 있는지는 현실세계의 `전화기`를 통해 알 수 있다.

여기서 현실세계와 객체세계의 `표현적 차이`또는 `의미적 차이` 가 생긴다.

이러한 차이를 줄이기 위해서 은유 관계에 놓인 두 객체에서 소프트웨어 객체의 이름을 현실세계 객체의 이름으로 사용한다.

이러한 이유로 현실세계의 도메인에서 사용되는 이름을 객체에 부여하라고 가이드한다.
