## 객체지향 설계의 3가지 관점

객체지향 세계를 설계하기 위해서는 자율적인 객체들에게 책임을 분배하는데,

결국 객체지향 언어에서 클래스를 통해 객체를 일반화 한다.

이렇게 클래스를 설계하는 방식을 `개념관점`, `명세관점`, `구현관점`에서 바라봐야 한다.

이들 세가지 관점이 어떤 순서로 행동 되어져야 하는건 아니다. 

만들어 내려고 하는 `클래스`가 위의 세가지 관점을 모두 **수용**할 수 있어야 하며, 코드에서는 세가지 관점을 식별할 수 있도록 깔끔하게 **분리** 되어있어야 한다.

### 개념관점

사용자가 해당 도메인에 대해서 생각하는 `본질적`인(잘 안변하는) 관점을 최대한 반영해야 한다.

본질적인것들이라 하면 비즈니스 자체거나 비즈니스 규칙과 같은 부분들이 속한다.

### 명세 관점

명세 관점은 소프트웨어에 초점을 두고 어떤 책임이 필요한지를 추출하여 객체들에게 분배 해야 한다.

여기서 협력을 이루기 위한 책임을 객체들에게 분배하고 객체들끼리 메시지를 주고받으며 협력의 공동목표를 이룬다.

여기서 객체들 사이에 메세지를 주고받기 위해 오픈된 공용 인터페이스를 바라보는것을 의미한다.

-> 즉, 책임을 찾고 객체에 분배하며, 객체들이 협력을 위해 '무엇을' 수행할 수 있는지를 집중하는 `공용 인터페이스`를 만든다.

### 구현 관점

구현관점은 객체들이 부여받은 책임을 수행하기 위해 필요한 동작 혹은 방법(메소드)의 코드를 작성하는 것이다.

즉, 객체가 해당 책임을 '어떻게' 수행할 것인지에 집중하게 되어, 인터페이스를 구현하는데 필요한 `속성`과 `메서드`를 클래스에 추가한다.

## 설계하고 구현하기

협력을 설계할 때에는 객체가 메시지를 선택하는 것이 아니라 메시지가 객체를 선택하게 해야 한다.

이말은 메세지를 먼저 선택하고 그 후에 메시지를 수신하기에 적절한 객체를 선택해야 한다는 것을 의미한다.

메세지를 수신하는 객체는 메시지를 처리할 책임을 맡게 되고, 해당 메시지는 객체가 외부에 제공하는 공용 인터페이스에 포함된다.

협력에 필요한 메시지를 선택하고 나서는 도메인 모델에서 해당 메시지를 수신할 적절한 객체를 선택하면 된다.

```
메시지: 커피를 주문하라
인자: 메뉴이름
리턴: 없음

수신객체: 손님이 해야할 책임
```

예를들어 메뉴 항목에 대한 정보를 얻으려고 하는 메시지가 있을 때, 메뉴 항목이라는 객체가 떠오를 것이다.

하지만 책임을 수행하는데 필요한 정보를 가진 객체에게 책임을 할당해야 하므로, 메뉴 항목 객체를 `포함`하고 있는 관계인 메뉴판 객체가 `책임`을 수행한다.

```
메시지: 메뉴 항목을 찾아라
인자: 메뉴 이름
리턴: 메뉴 항목

수신객체: 메뉴판
```

### 설계단계에서의 구현

머리속으로만 구상한 설계는 코드로 구현하는 단계에서 대부분 변경되기 마련이다.

설계 작업은 구현을 위한 스케치이지 곧바로 코드로 이어질 수 없다.

협력을 구상하는 단계에서 너무 오랜시간을 쏟지말고, 빠르게 코드화 시켜서 피드백을 얻어야한다.

## 코드로 보는 세가지 관점

결국 타입을 구현하는 것은 클래스이므로, 클래스를 통해 세가지 관점인 개념관점, 명세관점, 구현관점이 잘 녹아들여 있는지 확인한다.

**개념관점**에서 주로 봐야하는것은 **`도메인 모델`을 최대한 잘 반영했는지**? 를 궁극적으로 확인해야 한다.

이는 한편으로는 소프트웨어 클래스와 도메인 모델 내의 클래스사이의 간격이 충분히 좁아서, 유지보수에 있어서 용이하게 된다.

**명세 관점**에서는 해당 클래스내의 **`공용 인터페이스`**를 살펴보아야 한다.

인터페이스는 어디까지나 수정에 있어서 `위험구역이`므로, 이 위험구역이 최대한 작게 구성해야 한다.

즉, 인터페이스의 내부 구현은 철저하게 구현한 객체가 소유하고 선택할수 있도록 만들어야 한다.

**구현관점**에서는 해당 클래스의 `내부 구현`을 살펴본다. `내부구현`이라 하면 공용 인터페이스를 제외한 클래스 내부의 `구조`를 의미하게 된다.(`메소드`나 `속성` 등)

이러한 내부구현은 클래스의 일부분이지 공용 인터페이스의 부분이 아니므로, 원칙적으로 내부구현의 수정이 외부의 객체에게 영향을 미쳐선 안된다.

또한 클래스의 구조에 해당되므로, 해당 클래스의 객체는 객체 스스로가 자율적으로 관리하는 것이기 때문에, 철저하게 외부의 접근을 `캡슐화`로 막아야한다.





